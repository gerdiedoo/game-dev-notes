## Design Game Program Logic

1. **Formulate/Design Game Program Logic:**
   - This involves creating a high-level plan for how the game will function, including gameplay mechanics, interactions, and overall flow.
2. **Analyze Game Specifications:**
   - Understanding and analyzing the requirements of the game, which include features, mechanics, objectives, and constraints.
   - Mastery involves the ability to extract crucial information from game specifications, identify potential challenges, and suggest improvements or optimizations.

3. **Obtain, Review, and Clarify Design Documentation:**
   - Gathering and comprehending the documentation that outlines the design and mechanics of the game.
   - Mastery involves effective communication skills to interact with designers and stakeholders, ensuring a clear understanding of their vision.

4. **Conceptualize Game Technical Design:**
   - Creating a comprehensive plan that outlines how the game's systems will be implemented and interact with each other.
   - Mastery requires a strong grasp of software architecture principles, as well as the ability to foresee potential technical issues and design solutions.

5. **Analyze Game Physics:**
   - Understanding the physical rules and interactions within the game world, which can include gravity, collision detection, and object behaviors.
   - Mastery involves a solid foundation in physics principles and their application in a virtual environment.

6. **Identify and Solve Physics Problems/Equations Based on GDD:**
   - Using the information provided in the Game Design Document (GDD) to translate gameplay requirements into mathematical equations for physics simulations.
   - Mastery requires proficiency in both physics and mathematics, along with the ability to implement these equations in code.

7. **Apply Differentiation Based on GDD:**
   - Utilizing the GDD to determine different variations and possibilities in gameplay mechanics, adapting the game's behavior accordingly.
   - Mastery involves creative thinking and the ability to implement complex rules based on the GDD's differentiation requirements.

8. **Prepare Technical Game Documentation:**
   - Creating detailed documentation that explains the technical aspects of the game's implementation, including data structures, algorithms, and system interactions.
   - Mastery requires clear technical writing skills and the ability to convey complex concepts to both technical and non-technical stakeholders.

9. **Transform Requirements to Technical Design Document:**
   - Translating the high-level requirements and concepts from the GDD into a detailed technical design document.
   - Mastery involves the ability to bridge the gap between creative design and practical implementation, ensuring all aspects are covered.

10. **Illustrate Program Structures:**
    - Creating visual representations (flowcharts, diagrams) of how different parts of the game's codebase will interact.
    - Mastery requires a strong understanding of software architecture and the ability to communicate complex structures visually.

11. **Identify Resources for Coding and Testing of Program:**
    - Determining the tools, libraries, and frameworks needed to implement and test the game's features effectively.
    - Mastery involves staying up-to-date with the latest technologies and tools in the game development field.

12. **Prepare Concept Arts for GUI:**
    - Designing visual representations of the game's user interface (UI) elements based on the GDD.
    - Mastery involves a blend of artistic skills, UI/UX design principles, and the ability to align the visual style with the game's theme.

13. **Validate Technical Game Documentation:**
    - Ensuring that the technical design aligns with the requirements in the GDD and can be feasibly implemented.
    - Mastery requires meticulous attention to detail and a critical eye for spotting inconsistencies or potential issues.

14. **Check Technical Design Document:**
    - Reviewing and verifying the technical design document to confirm that all required technical aspects are covered.
    - Mastery involves the ability to critically assess documentation and provide constructive feedback to improve its quality.

## Apply Object Oriented Programming Language Skills

1. **Identify Game/Project Coding Standards:**
   - Understanding and adhering to the established coding conventions and guidelines specific to the game or project you're working on.
   - Mastery involves familiarity with the project's coding standards and the ability to consistently apply them for maintainable and coherent codebase.

2. **Apply Basic Language Syntax and Layout:**
   - Utilizing the fundamental syntax rules of the programming language to create readable and properly structured code.
   - Mastery requires a strong understanding of the chosen programming language's syntax, including variables, data types, operators, and control structures.

3. **Use and Customize Appropriate Language Syntax for Sequence, Selection, and Iteration Constructs:**
   - Implementing sequential, conditional (selection), and looping (iteration) logic using the appropriate language constructs.
   - Mastery involves being comfortable with designing and writing complex logic using these foundational programming constructs.

4. **Apply Basic Object-Oriented Principles in the Target Languages:**
   - Grasping the core concepts of object-oriented programming (OOP), such as classes, objects, encapsulation, inheritance, and polymorphism.
   - Mastery requires a deep understanding of how to design and implement solutions using OOP principles effectively.

5. **Implement a Class That Contains Primitive Member/Instance Variables:**
   - Creating a class that holds basic data members (variables) representing the attributes of an object.
   - Mastery involves understanding class design, instance variables, and their interaction within the broader system.

6. **Implement a Class That Contains Multiple Options for Object Constructions:**
   - Designing a class that offers different constructors to create instances with varying initializations.
   - Mastery requires a solid understanding of constructors, overloading, and design patterns that facilitate flexible object creation.

7. **Enforce a Class's Security Using Encapsulation:**
   - Restricting direct access to class members by using access modifiers, and providing controlled access through methods (getters and setters).
   - Mastery involves balancing security with usability and understanding when and how to apply encapsulation effectively.

8. **Implement Inheritance to at Least Two Levels of Depth:**
   - Creating a hierarchy of classes where subclasses inherit attributes and behaviors from parent classes, forming a chain.
   - Mastery requires planning class hierarchies, considering code reusability, and understanding how inheritance impacts code organization.

9. **Use Polymorphism via Inheritance to Enable Easy Code Extension:**
   - Leveraging polymorphism to allow objects of different subclasses to be treated as instances of a common superclass, enabling flexible code extension.
   - Mastery involves understanding virtual functions/methods, interfaces, and designing systems to accommodate change.

10. **Debug Codes:**
    - Identifying and resolving errors (bugs) in your code to ensure its correct functionality.
    - Mastery requires strong problem-solving skills, attention to detail, and experience in using debugging tools and techniques.

11. **Use Integrated Development Environment (IDE):**
    - Utilizing an integrated development environment that provides tools for coding, debugging, testing, and more.
    - Mastery involves becoming proficient with the specific IDE you're using, exploring its features, and customizing workflows.

12. **Use Program Debugging Techniques to Detect and Resolve Errors:**
    - Applying systematic approaches to identify and fix errors in your code, such as stepping through code, using breakpoints, and inspecting variables.
    - Mastery involves mastering various debugging techniques and strategies to efficiently track down and address issues.

13. **Follow Guidelines for Developing Maintainable Code:**
    - Writing code that is organized, well-documented, and easy to understand and modify in the future.
    - Mastery involves adopting best practices for clean code, modularization, and architecture to ensure long-term maintainability.

14. **Use and Follow Internal Documentation Standards:**
    - Adding comments, documentation, and explanations to your code that aid understanding and collaboration among team members.
    - Mastery involves consistent documentation habits, writing clear comments, and creating documentation that is both comprehensive and concise.

15. **Test Codes:**
    - Developing and executing test cases to verify that your code functions correctly and meets the requirements.
    - Mastery requires a strong understanding of testing methodologies, including unit testing, integration testing, and test-driven development.

16. **Develop and Conduct Simple Tests to Confirm the Coding Process:**
    - Creating and executing tests that cover various scenarios to validate the correctness of your code.
    - Mastery involves designing effective test cases, understanding testing frameworks, and interpreting test results.

17. **Document Activities:**
    - Keeping track of your progress, decisions, and changes during the development process through documentation.
    - Mastery involves maintaining detailed records, notes, and logs to facilitate collaboration, troubleshooting, and future improvements.

# Apply Programming Skills for In-Game Application

1. **Obtain Game Mechanics by Analyzing the GDD and TDD:**
   - Extracting the core gameplay mechanics, interactions, and features from the Game Design Document (GDD) and Technical Design Document (TDD).
   - Mastery requires a thorough understanding of game design principles, the ability to identify crucial gameplay elements, and how they translate into technical requirements.

2. **Analyze Technical Design Document:**
   - Reviewing the Technical Design Document to understand the architecture, components, and technical requirements of the game.
   - Mastery involves extracting technical details and comprehending how different elements of the game will be implemented and interact.

3. **Derive Technical Storyboard and Corresponding Pseudo Code from GDD and TDD:**
   - Creating a visual representation (storyboard) and pseudocode that outline the flow and logic of the game based on the GDD and TDD.
   - Mastery involves translating design concepts into precise, structured representations that guide the implementation process.

4. **Prepare Game Development Environment:**
   - Setting up the necessary tools, libraries, and software environment for game development.
   - Mastery requires familiarity with relevant development tools and ensuring they are properly configured for smooth workflow.

5. **Set the Necessary Hardware/Software to Code, Compile, and Run Game Development Tools:**
   - Configuring your computer hardware and software environment to support coding, compiling, and running game development tools.
   - Mastery involves troubleshooting potential setup issues and optimizing your development environment for efficiency.

6. **Apply Basic Language Syntax and Layout:**
   - Using the fundamental syntax rules of the chosen programming language to structure your code.
   - Mastery requires a strong foundation in the language's syntax and the ability to create clean and readable code.

7. **Use and Customize Appropriate Language Syntax for Sequence, Selection, and Iteration Constructs:**
   - Applying the appropriate programming constructs for sequencing, decision-making, and looping.
   - Mastery involves employing these constructs effectively to implement complex logic.

8. **Write Code for Game Application:**
   - Implementing the actual code for the game based on the technical design and requirements.
   - Mastery requires strong programming skills, understanding of algorithms, and the ability to translate design into functional code.

9. **Develop Working Prototype:**
   - Creating a functional version of the game that demonstrates core mechanics and features.
   - Mastery involves implementing essential gameplay elements to showcase the game's potential.

10. **Identify Game Module per Iteration:**
    - Breaking down the game development process into manageable modules or features for iterative development.
    - Mastery involves careful planning and prioritization of which modules to develop in each iteration.

11. **Define and Explain Game Loop:**
    - Designing the core loop that drives the gameplay, including input processing, updating game state, and rendering.
    - Mastery requires understanding the mechanics of real-time game loops and how they affect the player experience.

12. **Create and Implement Program Code:**
    - Writing the code that brings the game's mechanics, interactions, and features to life.
    - Mastery involves efficiently translating design specifications into functional code, considering performance and maintainability.

13. **Use Mathematical Concepts and Techniques in Controlling and Implementing Game Systems:**
    - Applying mathematical principles for physics simulations, animations, AI behaviors, and other game systems.
    - Mastery requires a strong understanding of relevant math concepts and their application in game development.

14. **Use Style and Design Principles to Solve Common Game Programming Problems:**
    - Applying coding patterns and design principles that address common challenges in game development.
    - Mastery involves using techniques that balance performance, readability, and maintainability.

15. **Use and Customize Data Structures and Algorithms to Ensure Robust and Fast Implementation of Game Systems:**
    - Selecting and adapting data structures and algorithms to optimize performance and memory usage.
    - Mastery requires familiarity with data structures, algorithms, and their application in game development contexts.

16. **Identify and Apply Appropriate Design Patterns in Coming Up with Initial Prototype:**
    - Recognizing and implementing design patterns that solve recurring problems in game development.
    - Mastery involves understanding a wide range of design patterns and knowing when to apply them effectively.

17. **Execute and Test the Game Application:**
    - Running the game and conducting thorough testing to identify and fix bugs and issues.
    - Mastery involves using testing methodologies, tools, and techniques to ensure the game functions as intended.

18. **Check Workability of the Prototype:**
    - Verifying that the prototype's mechanics and features align with the design specifications.
    - Mastery requires a critical eye for detail and the ability to identify discrepancies between the prototype and the intended design.

19. **Evaluate Prototype Based on GDD:**
    - Comparing the prototype's implementation with the goals outlined in the Game Design Document.
    - Mastery involves assessing whether the prototype captures the intended player experience and gameplay.

20. **Apply Prototype Iteration Based on Evaluation Results:**
    - Using feedback and evaluation results to refine and improve the prototype's design and functionality.
    - Mastery requires openness to feedback and the ability to iteratively refine the game's mechanics.

21. **Implement Iterative Prototyping Cycle Until Game Final Prototype Is Approved:**
    - Repeating the prototype-evaluate-refine cycle until the game's prototype meets the desired quality and functionality.
    - Mastery involves managing the iteration process efficiently and effectively.

22. **Refine/Debug a System:**
    - Identifying and addressing issues within specific game systems or components to improve their functionality and performance.
    - Mastery requires deep system understanding, debugging skills, and the ability to optimize existing code.

23. **Assess Game Prototype to Follow Quality Assurance/Testing Techniques:**
    - Applying various testing techniques and methodologies to ensure the prototype's stability, reliability, and quality.
    - Mastery involves using testing frameworks and practices to thoroughly test different aspects of the game.

24. **Address Overall Game Design Concerns:**
    - Resolving design-related challenges or inconsistencies that arise during the development process.
    - Mastery involves a holistic understanding of game design principles and the ability to make design decisions that enhance the player experience.

25. **Optimize a Game Program Based on Project Requirements:**
    - Enhancing the game's performance, responsiveness, and efficiency based on specific project requirements.
    - Mastery requires profiling and analyzing code to identify bottlenecks and implementing optimizations.

